#!/usr/bin/env python

import argparse
import yaml
#import weakref
import pprint
import math
from midiutil import MIDIFile
import networkx as nx

"""
Argumentos y parametros globales
"""
parser = argparse.ArgumentParser()
parser.add_argument( 
 'archivos',
 help  = 'Al menos un archivo en formato YAML para procesar',
 type  = argparse.FileType( 'r' ),
 nargs = '+'
)
parser.add_argument( 
 '-v',
 '--verbosity',
 help = 'Imprimir informacion',
)
parser.add_argument( 
 '-o',
 '--output',
 default = 'output',
 help = 'Nombre del archivo de salida',
)
parser.add_argument( 
 '-p',
 '--plot',
 help = 'Ploteo del arbol de relaciones entre unidades.(dot รณ png)',
)
args = parser.parse_args()

definiciones = []
for archivo in args.archivos:
  data = open( archivo.name, 'r' )
  definiciones.append( yaml.load( data ) )

verboseprint = print if args.verbosity else lambda *a, **k: None
salida = args.output

if args.plot:
  import matplotlib.pyplot as plt
  if args.plot == 'png':
    from networkx.drawing.nx_agraph import graphviz_layout
  if args.plot == 'dot':
    from networkx.drawing.nx_agraph import write_dot


class Pista:
  """
  Clase para cada track a partir de archivos.yml
  """
  cantidad = 0 
  defactos = {
    'bpm'           : 60,
    'canal'         : 1,
    'programa'      : None,
    'metro'         : '4/4',
    'alturas'       : [ 1 ],
    'intervalos'    : [ 1 ],
    'voces'         : None,
    'duraciones'    : [ 1 ],
    'dinamicas'     : [ 1 ],
    'transportar'   : 0,
    #'octava'        : 0,
    'controladores' : [ None ],
    'repeticiones'  : 1,
    'referente'  : None,
  }
 
  def __init__( 
    self,
    nombre,
    base,
    paleta,
    macroforma,
  ):
    self.nombre = nombre
    self.orden = Pista.cantidad 
    Pista.cantidad += 1
    self.uid = self.nombre + str( self.orden )
    self.base = base
    self.paleta = paleta # paleta de unidades, no objetadas todavia
    self.macroforma = macroforma
    self.registros = {}
    self.unidades = {} 
    for unidad in self.paleta:
      self.unidades[ unidad ] = Unidad( 
        unidad, #nombre
        self.paleta[ unidad ], # propiedades de la unidad 
        self,
      )
    self.secuencia  = self.secuenciar()

    pprint.pprint( self.registros )

    # encapsular
    self.arbol = nx.OrderedDiGraph()
    for r in self.registros:
      registro = self.registros[ r ]
      NODOS = [] 
      RELACIONES = [] 
      for u in registro:
          if u in self.paleta:
           uo = self.unidades[ u ]
           NODOS.append( uo.rid )

      self.arbol.add_nodes_from( NODOS )

    verboseprint( '\n#### ', self.nombre, ' ####' )

  def __str__( self ):
    o = '' 
    for attr, value in self.__dict__.items():
      l = str( attr ) + ':' + str( value )
      o += l + '\n'
    return o

  # Genera una secuencia a partir de unidades/parametros
  def secuenciar( 
    self,
    unidades = None,
    nivel = 0,
    referente = {},
  ):
    #unidades a secuenciar
    unidades = unidades if unidades is not None else self.macroforma
    nivel += 1
    sequencia = []

    for i, u in enumerate( unidades ):  
      verboseprint( '-' * ( nivel - 1 ) +  u  )

      if u in self.unidades:
        uo = self.unidades[ u ]

        if not uo.unidades:
          # Solo unidades de nivel 0 (no UoU) se secuencian 
          self.registros.setdefault( 'copa', [] ).append( uo.uid)
          # Mix parametros con unidad referente
          resultado = {
            **Pista.defactos,
            **uo.parametros,
            **referente
          } 
          intervalos = resultado['intervalos']
          alturas = resultado['alturas']
          voces = resultado['voces']
          duraciones = resultado['duraciones']
          dinamicas = resultado['dinamicas']
          controladores = resultado['controladores']
          candidatos = [ 
            dinamicas,
            duraciones,
            alturas,
            controladores,
          ]
          ganador = max( candidatos, key=len )
          pasos = len( ganador )

          for paso in range( pasos ):
            # Combinar parametros: altura, duracion, dinamica, etc
            duracion  = duraciones[ paso % len( duraciones ) ]
            dinamica  = dinamicas[ paso % len( dinamicas ) ]
            controlador  = controladores[ paso % len( controladores ) ]
            alt  = alturas[ paso % len( alturas ) ]
            acorde = []

            if alt != 0:
              # Ajuste relacion altura / puntero intervalo
              alt = alt - 1
              nota = intervalos[ alt % len( intervalos ) ] + resultado['transportar']

              if voces:
                for voz in voces:
                  if voz[ paso % len( voz ) ] != 0:
                    fund = alt + ( voz[ paso % len( voz ) ] - 1 )
                    acorde += [ intervalos[ fund % len( intervalos ) ]  + resultado[ 'transportar' ] ]
                  else:
                    acorde += [ 'S' ]
            else:
              # Silencio
              nota = 'S'
            evento = {
              'orden'       : paso,
              'unidad'      : u,
              'referente'   : resultado['referente'],
              #'referentes'  : resultado['referentes'],
              'canal'       : resultado['canal'],
              'programa'    : resultado['programa'],
              'bpm'         : resultado['bpm'],
              'metro'       : resultado['metro'],
              'transportar' : resultado['transportar'],
              #'octava'     : resultado['octava'],
              'altura'      : nota,
              'acorde'      : acorde,
              'duracion'    : duracion,
              'dinamica'    : dinamica,
              'controlador' : controlador,
            }
            sequencia.append( evento )
        else: 
          self.registros.setdefault( nivel, [] ).append( uo.uid)
          mezcla = { 
            **uo.parametros,
            **referente
          }
          mezcla['referente'] = uo.uid 
          sequencia += self.secuenciar( 
            uo.unidades,
            nivel,
            mezcla,
          ) 
          
    return sequencia

class Unidad:
  """
  Clase para las unidades de cada track
  TO DO: pasar a dataclass
  """
  cantidad = 0

  def __init__( 
    self,
    nombre,
    parametros,
    pista, 
  ):
    self.nombre = nombre 
    self.parametros = parametros 
    self._referentes = []
    #self.pesta = weakref.ref( pista )
    self.pista = pista 
    Unidad.orden = Unidad.cantidad
    Unidad.cantidad += 1
    self.uid = self.nombre + str( self.orden ) 
    self.etiqueta = self.uid
    # TODO contar repeticiones en todos los niveles
    #self.repeticion = self.pista.registros['copa'].count( self.nombre ) if 'copa' in self.pista.registros else 0 
    #self.rid = self.nombre + str( self.repeticion )

  def __str__( self ):
    return self.nombre

  # Unidad de Unidades
  @property
  def unidades( self ):
    if 'unidades' in self.parametros:
      return self.parametros[ 'unidades' ]

  def mostrar_cantidad( self ):
    print( "Cantidad de Unidades: %d" % Unidad.cantidad )

      
"""
Carga de pistas a partir de las definiciones
"""
pistas = []
for d in definiciones:
  pista = Pista(
    d['nombre'],
    d['base'],
    d['unidades'],
    d['macroforma'],
  )
  pistas.append( pista )

"""
Loop principal:
Recorre cada pista y partir de su secuencia genera Notas o Silencios que agrupa
en una Parte para finalmente agregarlas a una Partirtura de Musescore
"""
opus = MIDIFile( Pista.cantidad ) 
for pista in pistas:
  if args.plot:
    print('#### PLOTEANDO ####')
    # TODO ordenar grafico del graph 

    if args.plot == 'png':
      plt.title(  pista.nombre )
      pos = graphviz_layout( 
        pista.arbol,
        prog = 'dot',
        #ordering = 'out',
        args='',
      )
      nx.draw(
        pista.arbol,
        pos,
        with_labels = True,
        arrows = True,
      )
      plt.savefig( pista.nombre.lower() + '.png' )

    if args.plot == 'dot':
      write_dot(
        pista.arbol,
        pista.nombre.lower() + '.dot'
      )

  momento = 0
  track = pista.orden
  opus.addTrackName(
    track,
    momento,
    pista.nombre
  )
  opus.addTempo(
    track,
    momento,
    pista.base['bpm']
  )
  """
  Time Signature event
  https://midiutil.readthedocs.io/en/1.2.1/class.html#midiutil.MidiFile.MIDIFile.addTimeSignature
  The denominator is a negative power of two: log10( X ) / log10( 2 ) 
  2 represents a quarter-note, 3 represents an eighth-note, etc.
  """
  numerador, denominador = pista.base['metro'].split( '/' )
  denominador = int( math.log10( int( denominador ) ) / math.log10( 2 ) )
  relojes_por_tick = 12 * denominador
  notas_por_negra = 8
  opus.addTimeSignature( 
    track,
    momento,
    int( numerador ),
    denominador,
    relojes_por_tick, 
    notas_por_negra
  )

  if 'programa' in pista.base:
    opus.addProgramChange(
      track,
      pista.base['canal'],
      momento, 
      pista.base['programa']
    )
  for index, evento in enumerate( pista.secuencia ):
    evento = pista.secuencia[ index ]
    verboseprint( evento )
    previo = pista.secuencia[ index - 1 ]
    unidad = evento['unidad']
    canal = evento['canal']
    bpm = evento['bpm']
    if ( previo['bpm'] != bpm ):
      opus.addTempo(
        track,
        momento,
        bpm,
      )
    metro = evento['metro']
    if ( previo['metro'] != metro ):
      numerador, denominador = metro.split( '/' )
      denominador = int( math.log10( int( denominador ) ) / math.log10( 2 ) )
      relojes_por_tick = 12 * denominador
      notas_por_negra = 8
      opus.addTimeSignature( 
        track,
        momento,
        int( numerador ),
        denominador,
        relojes_por_tick, 
        notas_por_negra
      )
    programa = evento['programa']
    if programa:
      if ( previo['programa'] != programa ):
        opus.addProgramChange(
          track,
          canal, 
          momento, 
          programa
        )
        #opus.addText( pista.orden, momento , 'prgm : #' + str( programa ) )
    if ( evento['orden'] == 0 ):
      uo = pista.unidades[ unidad ] 
      #print( nx.ancestors( pista.arbol, unidad + str( uo.orden ) ) )

      st = unidad
      if (
        'referente' in evento
      ):
        st =  str( evento[ 'referente' ] )  + '-->' + unidad 
        print(st)

      opus.addText(
        track,
        momento,
        st
      )
    # altura = evento['altura']
    # ARREGLAR RELACION ENTRE VOZ de ACORDE y ALTURA 
    voces = evento['acorde'] if evento['acorde'] else [ evento['altura'] ]

    duracion = evento['duracion'] 
    dinamica = int( evento['dinamica'] * 126 )

    for voz in voces:
      altura = voz 
      if voz == 'S':
        dinamica = 0
        altura = 0
      opus.addNote( 
        track, 
        canal, 
        altura , 
        momento, 
        duracion, 
        dinamica ,
      )

    if evento['controlador']:
      for controlador, parametro in evento['controlador'].items():
        opus.addControllerEvent( 
          track, 
          canal, 
          momento, 
          controlador, 
          parametro, 
        )
    momento = momento + duracion

"""
Salida
"""
with open( salida + ".mid", "wb" ) as output_file:
  opus.writeFile( output_file )

