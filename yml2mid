#!/usr/bin/env python3

import argparse
import yaml
import weakref
import pprint
import math
#from music21 import *

from midiutil import MIDIFile


"""
Manejo de argumentos y parametros globales
"""
parser = argparse.ArgumentParser()
parser.add_argument( 
 'archivos',
 help  = 'Al menos un archivo en formato YAML para procesar',
 type  = argparse.FileType( 'r' ),
 nargs = '+'
)
parser.add_argument( 
 '-v',
 '--verbosity',
 help = 'Imprimir informacion',
)
parser.add_argument( 
 '-f',
 '--formato',
 help = 'Formato de salida (op: midi, musicxml, text).',
)
args = parser.parse_args()
definiciones = []
for archivo in args.archivos:
  data = open( archivo.name, 'r' )
  definiciones.append( yaml.load( data ) )
verboseprint = print if args.verbosity else lambda *a, **k: None
formato_salida = args.formato 

class Pista:
  """
  Clase para cada track a partir de archivos.yml
  """
  cantidad = 0 
 
  def __init__( 
    self,
    nombre,
    defaults,
    paleta,
    macroforma,
  ):
    self.nombre = nombre
    self.defaults = defaults
    self.paleta = paleta
    self.macroforma = macroforma

    self.secuencia  = self.secuenciar()
    self.orden = Pista.cantidad 
    Pista.cantidad += 1

    verboseprint( '\n#### ', self.nombre, ' ####' )

  def __str__( self ):
    o = '' 
    for attr, value in self.__dict__.items():
      l = str( attr ) + ':' + str( value )
      o += l + '\n'
    return o

  # Paleta de Unidades
  @property
  def unidades( self ):
    unidades = {} 
    for unidad in self.paleta:
      uo = Unidad( 
        unidad, 
        self.paleta[ unidad ], 
        self
      )
      unidades[ unidad ] =  uo
    return unidades

  # Genera una secuencia a partir de unidades/parametros
  def secuenciar( 
    self,
    unidades = None,
    nivel = 0,
    pisar = {},
  ):
    unidades = unidades if unidades is not None else self.macroforma
    paleta = self.unidades
    nivel += 1
    sequencia = []
    for u in unidades:  
      verboseprint( '-' * ( nivel - 1 ) + str( u ) )
      if u in paleta:
        uo = paleta[ u ]
        # Mix propiedades con unidad referente
        referente = { **uo.parametros , **pisar }
        if uo.unidades:
          referente.setdefault('referentes',[]).insert( 0,str( u ) )
          sequencia += self.secuenciar( uo.unidades, nivel, referente ) 
        # Solo unidades de nivel 0 (no UoU) se secuencian 
        else: 
          # Mix parametros con unidad referente
          resu = { **uo.parametros, **referente } 
          unid = str( uo )
          refe = resu['referentes'] if 'referentes'       in resu else None 
          bpm  = resu['bpm']        if 'bpm'              in resu else 60 
          cana = resu['canal']      if 'canal'            in resu else 1 
          prog = resu['programa']   if 'programa'         in resu else None 
          metr = resu['metro']      if 'metro'            in resu else '4/4'
          alts = resu['alturas']    if 'alturas'          in resu else [1] 
          ints = resu['intervalos'] if 'intervalos'       in resu else [1]
          vozs = resu['voces']      if 'voces'            in resu else None
          durs = resu['duraciones'] if 'duraciones'       in resu else [1]
          dins = resu['dinamicas']  if 'dinamicas'        in resu else [1]
          #octa = resu['octava']     if 'octava'          in resu else 0
          trar = resu['transportar'] if 'transportar'     in resu else 0
          ctrs = resu['controladores'] if 'controladores' in resu else [0] 
          candidatos = [ 
            dins,
            durs,
            alts,
            ctrs,
          ]
          ganador = max( candidatos, key=len )
          pasos = len( ganador )
          # Combinar parametros: altura, duracion, dinamica, etc
          for paso in range( pasos ):
            alt  = alts[ paso % len( alts ) ]
            acor = []
            if alt != 0:
              # Ajuste relacion altura /puntero intervalo
              alt = alt - 1
              nota = ints[ alt % len( ints ) ] + trar
              if vozs:
               for voz in vozs:
                 if voz[ paso % len( voz ) ] != 0:
                   fund = alt + ( voz[ paso % len( voz ) ] - 1)
                   acor += [ ints[ fund % len( ints ) ]  + trar]
                 else:
                   acor += [ 'S'  ]

            else:
              # Silencio
              nota = 'S'
            dura  = durs[ paso % len( durs ) ]
            dina  = dins[ paso % len( dins ) ]
            ctrl  = ctrs[ paso % len( ctrs ) ]
            evento = {
              'orden'       : paso,
              'canal'       : cana,
              'programa'    : prog,
              'unidad'      : unid,
              'referentes'  : refe,
              'bpm'         : bpm,
              'metro'       : metr,
              'altura'      : nota,
              'acorde'      : acor,
              'duracion'    : dura,
              'dinamica'    : dina,
              #'octava'     : octa,
              'transportar' : trar,
              'controlador' : ctrl,
            }
            sequencia.append( evento )
    return sequencia

class Unidad:
  """
  Clase para las unidades de cada track
  TO DO: pasar a dataclass
  """
  cantidad = 0
  def __init__( 
    self,
    nombre,
    parametros,
    track
  ):
    self.nombre = nombre 
    self.parametros = parametros 
    self.track = weakref.ref( track )
    Unidad.cantidad += 1

  def __str__( self ):
    return self.nombre

  def mostrar_cantidad( self ):
    print( "Cantidad de Unidades: %d" % Unidad.cantidad )

  # Unidad de Unidades
  @property
  def unidades( self ):
    if 'unidades' in self.parametros:
      return self.parametros['unidades']
      
#def larguest( l ):
#  """
#  Devuelve el tama√±o de la lista mas larga
#  https://stackoverflow.com/questions/30902558
#  """
#  if( not isinstance( l, list ) ): return(0)
#  return( 
#    max( 
#      [ len( l ) , ] + 
#      [ len( subl ) for subl in l if isinstance( subl, list ) ] +
#      [ larguest( subl ) for subl in l ]
#    )
#  )

"""
Carga de pistas a partir de las definiciones
"""
pistas = []
for d in definiciones:
  pista = Pista(
    d['nombre'],
    d['base'],
    d['unidades'],
    d['macroforma'],
  )
  pistas.append( pista )

"""
Loop principal:
Recorre cada pista y partir de su secuencia genera Notas o Silencios que agrupa
en una Parte para finalmente agregarlas a una Partirtura de Musescore
"""
opus = MIDIFile( Pista.cantidad ) 
for pista in pistas:
  momento = 0
  track = pista.orden
  opus.addTrackName(
    track,
    momento,
    pista.nombre
  )
  opus.addTempo(
    track,
    momento,
    pista.defaults['bpm']
  )
  """
  Time Signature event
  https://midiutil.readthedocs.io/en/1.2.1/class.html#midiutil.MidiFile.MIDIFile.addTimeSignature
  The denominator is a negative power of two: log10( X ) / log10( 2 ) 
  2 represents a quarter-note, 3 represents an eighth-note, etc.
  """
  numerador, denominador = pista.defaults['metro'].split( '/' )
  denominador = int( math.log10( int( denominador ) ) / math.log10( 2 ) )
  relojes_por_tick = 12 * denominador
  notas_por_negra = 8
  opus.addTimeSignature( 
    track,
    momento,
    int( numerador ),
    denominador,
    relojes_por_tick, 
    notas_por_negra
  )

  if 'programa' in pista.defaults:
    opus.addProgramChange(
      track,
      pista.defaults['canal'],
      momento, 
      pista.defaults['programa']
    )
  for index, evento in enumerate( pista.secuencia ):
    evento = pista.secuencia[ index ]
    verboseprint( evento )
    previo = pista.secuencia[ index - 1 ]
    unidad = evento['unidad']
    canal = evento['canal']
    bpm = evento['bpm']
    if ( previo['bpm'] != bpm ):
      opus.addTempo(
        track,
        momento,
        bpm,
      )
    metro = evento['metro']
    if ( previo['metro'] != metro ):
      numerador, denominador = metro.split( '/' )
      denominador = int( math.log10( int( denominador ) ) / math.log10( 2 ) )
      relojes_por_tick = 12 * denominador
      notas_por_negra = 8
      opus.addTimeSignature( 
        track,
        momento,
        int( numerador ),
        denominador,
        relojes_por_tick, 
        notas_por_negra
      )
    programa = evento['programa']
    if programa:
      if ( previo['programa'] != programa ):
        opus.addProgramChange(
          track,
          canal, 
          momento, 
          programa
        )
        #opus.addText( pista.orden, momento , 'prgm : #' + str( programa ) )
    if ( evento['orden'] == 0 ):
      # TODO mostrar repeticion de unidades referentes 
      st = unidad
      referentes = evento['referentes'] 
      if referentes and ( 
        previo['referentes'] != referentes 
      ):
        for i,r in enumerate( referentes ):
          st = st + '\n'+ r 

      opus.addText(
        track,
        momento,
        st
      )

    #altura = evento['altura']
    voces = [ evento['altura'] ]
    if evento['acorde']:
      voces = evento['acorde']

    duracion = evento['duracion'] 
    dinamica = int( evento['dinamica'] * 126 )
    for voz in voces:
      altura = voz 
      if voz == 'S':
        dinamica = 0
        altura = 0
      opus.addNote( 
        track, 
        canal, 
        altura , 
        momento, 
        duracion, 
        dinamica ,
      )

    if evento['controlador']:
      for controlador, parametro in evento['controlador'].items():
        opus.addControllerEvent( 
          track, 
          canal, 
          momento, 
          controlador, 
          parametro, 
        )
    momento = momento + duracion

"""
Salida
"""
with open( "prueba.mid", "wb" ) as output_file:
  opus.writeFile( output_file )

