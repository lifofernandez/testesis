#!/usr/bin/env python
import argparse
import yaml
import pprint
import math
from midiutil import MIDIFile
#from midiutil import *
import random
"""
Argumentos y parametros globales
"""
parser = argparse.ArgumentParser()
parser.add_argument( 
 'archivos',
 help  = 'Al menos un archivo en formato YAML para procesar',
 type  = argparse.FileType( 'r' ),
 nargs = '+'
)
parser.add_argument( 
 '-v',
 '--verbosity',
 help = 'Imprimir informacion',
)
parser.add_argument( 
 '-o',
 '--output',
 default = 'output',
 help = 'Nombre del archivo de salida',
)
parser.add_argument( 
 '-p',
 '--plot',
 help = 'Ploteo del arbol de relaciones entre unidades.(dot ó png)',
)
args = parser.parse_args()

definiciones = []
for archivo in args.archivos:
  data = open( archivo.name, 'r' )
  definiciones.append( yaml.load( data ) )
verboseprint = pprint.pprint if args.verbosity else lambda *a, **k: None
salida = args.output
if args.plot:
  from graphviz import Digraph
class Pista:
  """
  Clase para cada 'track' a partir de archivos.yml
  """
  cantidad = 0 
  defactos = {
    'bpm'           : 60,
    'canal'         : 1,
    'programa'      : None,
    'metro'         : '4/4',
    'alturas'       : [ 1 ],
    'clave'         : { 'alteraciones' : 0, 'modo' : 0 },
    'intervalos'    : [ 1 ],
    'voces'         : None,
    'duraciones'    : [ 1 ],
    'dinamicas'     : [ 1 ],
    'fluctuacion'   : [ 1, 1 ], 
    'transportar'   : 0,
    'transponer'    : 0,
    'controladores' : [ None ],
    'reiterar'      : 1,
    'referente'     : None,
  }
 
  def __init__( 
    self,
    nombre,
    base,
    paleta,
    macroforma,
  ):
    self.nombre = nombre
    self.orden = Pista.cantidad 
    Pista.cantidad += 1
    self.oid = str( self.orden ) + self.nombre 
    self.base = base
    self.paleta = paleta # paleta de unidades
    self.macroforma = macroforma
    self.grafico = Digraph(
      'G',
      filename = 'cluster.gv'
    )
    self.grafico.graph_attr[ 'rankdir' ] = 'LR'
    self.grafico.graph_attr[ 'constraint' ] = 'false'
    self.grafico.graph_attr[ 'rank' ] = 'same'
    self.registros = {}
    self.secuencia = [] 
    self.ordenar()
    #self.secuencia = self.ordenar( macroforma )
    #pprint.pprint( self.registros )
    #if args.plot:
    
    # NOTE: the subgraph name needs to begin with 'cluster' (all lowercase)
    #       so that Graphviz recognizes it as a special cluster subgraph
    
    with self.grafico.subgraph( name = 'cluster_0' ) as uno:
      uno.attr( 
        style = 'filled',
        rank = 'same',
        rankdir = 'LR',
        color = 'red',
        constraint = 'false',
        label = 'process #1'
      )
      uno.edges( [
        ( 'a0', 'a1' ),
        ( 'a1', 'a2' ),
        ( 'a2', 'a3' )
      ] )
    
      with uno.subgraph( name = 'cluster_2' ) as dos:
        dos.attr(
          style = 'filled',
          label = 'process #2',
          color = 'blue' ,
          rank = 'same',
          constraint = 'false',
          rankdir = 'LR',
        )

        with dos.subgraph( name = 'cluster_3' ) as tres:
          tres.attr(
            style = 'filled',
            label = 'process #3',
            color = 'green',
            rank = 'same',
            constraint = 'false',
            rankdir = 'LR',
          )
          tres.edges( [
            ( 'd0', 'd1' ),
            ( 'd1', 'd2' ),
          ] )

        dos.node( 
          'z1',
        )

        with dos.subgraph( name = 'cluster_4' ) as cuatro:
          cuatro.attr(
            style = 'filled',
            label = 'process #4',
            rank = 'same',
            rankdir = 'LR',
            constraint = 'false',
            color = 'pink' 
          )
          cuatro.node( 
            'g1',
          )
        dos.node( 
          'b0',
        )
        with dos.subgraph( name = 'cluster_5' ) as cinco:
          cinco.attr(
            style = 'filled',
            label = 'process #5',
            rank = 'same',
            constraint = 'false',
            color = 'yellow' 
          )
          cinco.edges( [
            ( 'f0', 'f1' ),
            ( 'f1', 'f2' ),
          ] )

      uno.edges( [ 
         ( 'a3', 'd0' ),
         ( 'd2', 'z1' ),
         ( 'z1', 'g1' ),
         ( 'g1', 'b0' ),
         ( 'b0', 'f0' ),
      ])

    #self.grafico.edge( 'start', 'a0' )
    #self.grafico.edge( 'start', 'b0' )
    #self.grafico.edge( 'a1', 'b3' )
    #self.grafico.edge( 'b2', 'a3' )
    #self.grafico.edge( 'a3', 'a0' )
    #self.grafico.edge( 'a3', 'end' )
    #self.grafico.edge( 'b3', 'end' )

    #self.grafico.node( 'start', shape = 'Mdiamond' )
    #self.grafico.node( 'end', shape = 'Msquare' )


    verboseprint( '\n#### ' + self.nombre + ' ####' )

  def __str__( self ):
    o = '' 
    for attr, value in self.__dict__.items():
      l = str( attr ) + ':' + str( value )
      o += l + '\n'
    return o

  def ordenar( 
    self,
    forma    = None,
    nivel    = 0,
    herencia = {},
  ):
    """
    Organiza unidades según relacion de referencia
    """
    forma = forma if forma is not None else self.macroforma
    nivel += 1
    herencia.pop( 'unidades', None )
    herencia.pop( 'reiterar', None )

    for u in forma:  
      verboseprint( '-' * ( nivel - 1 ) +  u  )
      if u in self.paleta:
        uo = self.paleta[ u ]
        # TODO q cuente recurrencias en todos ls niveles
        recurrencia = sum( 
          [ 1 for o in self.registros[ nivel ] if o[ 'nombre' ] == u ]
        ) if nivel in self.registros else 0 
        registro = { 
          'nombre'      : u,
          'recurrencia' : recurrencia,
          'nivel'       : nivel,
        }
        if 'referente' in herencia:
          registro[ 'referente' ] = herencia[ 'referente' ] 
        sucesion = {
          **uo,
          **herencia,
          **registro
        } 

        reiterar = uo[ 'reiterar' ] if 'reiterar' in uo else 0
        for r in range( reiterar + 1):
          self.registros.setdefault( nivel , [] ).append( registro )
          if 'unidades' in uo:
            sucesion[ 'referente' ] = registro 

            #with self.grafico.subgraph( name = 'cluster_' + str( u ) ) as c:
            #    c.attr(
            #      label = u,
            #    )
            #    #c.node( u + 'test' )
            #    for uu in uo[ 'unidades'  ]:
            #      c.node( uu )

            self.ordenar( 
              uo[ 'unidades' ],
              nivel,
              sucesion,
            ) 

          else: 
            # TODO Contar 'recurrencias' que suenan (en el nivel superior)
            self.registros.setdefault( 'copa' , [] ).append( registro )
            factura = {
              **Pista.defactos,
              **sucesion,
            } 
            o = self.secuenciar( factura ) 
            self.secuencia += o  

  def secuenciar( 
    self,
    unidad
  ):
    """
    Genera una secuencia de eventos a partir de unidades preprocesadas
    """
    revertir = unidad['revertir'] if 'revertir' in unidad else None 
    if isinstance( revertir , list ):
      for r in revertir:
        if r in unidad:
          unidad[ r ].reverse() 
    elif isinstance( revertir , str ):
      if revertir in unidad:
        unidad[ revertir ].reverse() 
    intervalos    = unidad[ 'intervalos' ]
    alturas       = unidad[ 'alturas' ]
    voces         = unidad[ 'voces' ]
    duraciones    = unidad[ 'duraciones' ]
    dinamicas     = unidad[ 'dinamicas' ]
    controladores = unidad[ 'controladores' ]
    candidatos = [ 
      dinamicas,
      duraciones,
      alturas,
      controladores,
    ]
    ganador = max( candidatos, key=len )
    pasos = len( ganador )
    seq = []
 
    for paso in range( pasos ):
      """
      Combinar parametros: altura, duracion, dinamica, etc
      """
      duracion = duraciones[ paso % len( duraciones ) ]
      fluctuacion = 1
      if isinstance( unidad[ 'fluctuacion' ], list ):
        fluctuacion = random.uniform( 
          unidad[ 'fluctuacion' ][0],
          unidad[ 'fluctuacion' ][1] 
        )
      dinamica = dinamicas[ paso % len( dinamicas ) ] * fluctuacion
      controlador = controladores[ paso % len( controladores ) ]
      altura = alturas[ paso % len( alturas ) ]
      acorde = []
      nota = 'S' # Silencio
      if altura != 0:
        """
        altura / puntero intervalo
        """
        transponer  = unidad[ 'transponer' ] 
        transportar = unidad[ 'transportar' ]
        nota = transportar + intervalos[ ( altura - 1 ) + transponer % len( intervalos ) ] 
        if voces:
          for voz in voces:
            tonica = altura + ( voz[ paso % len( voz ) ] ) - 1 
            acorde += [ transportar +  intervalos[ tonica + transponer % len( intervalos ) ]  ]
      evento = {
        **unidad,
        'unidad'      : unidad[ 'nombre' ],
        'orden'       : paso,
        'altura'      : nota,
        'acorde'      : acorde,
        'duracion'    : duracion,
        'dinamica'    : dinamica,
        'controlador' : controlador,
      }
      seq.append( evento )
    return seq 

def referir(
  refs,
  oi = None,
  ):
  """
  Extrae referentes recursivamente
  """
  referente   = refs[ 'referente' ]   if 'referente'   in refs else None
  nombre      = refs[ 'nombre' ]      if 'nombre'      in refs else None
  recurrencia = refs[ 'recurrencia' ] if 'recurrencia' in refs else None
  nivel       = refs[ 'nivel' ]       if 'nivel'       in refs else None
  output      = oi                    if oi is not None        else [ None ] * nivel 
  output[ nivel - 1 ] = ( nombre, recurrencia )
  if referente:
    referir( referente, output )
  return output

pistas = []
for d in definiciones:
  """
  Carga de pistas a partir de las definiciones
  """
  pista = Pista(
    d[ 'nombre' ],
    d[ 'base' ],
    d[ 'unidades' ],
    d[ 'macroforma' ],
  )
  pistas.append( pista )

opus = MIDIFile( Pista.cantidad ) 
for pista in pistas:
  """
  Loop principal:
  """
  if args.plot:
    print( '#### PLOTEANDO ####' )
    pista.grafico.view( )
    #pista.grafico.draw(
    #  'file.png',
    #  format = 'png',
    #  prog   = 'dot'
    #)
    #if args.plot == 'dot':
    #  write_dot(
    #    pista.grafico,
    #    pista.nombre.lower() + '.dot'
    #  )
  momento = 0
  track = pista.orden
  opus.addTrackName(
    track,
    momento,
    pista.nombre
  )
  if 'bpm' in pista.base:
    opus.addTempo(
      track,
      momento,
      pista.base['bpm']
    )
  if 'metro' in pista.base:
    """
    Time Signature event
    https://midiutil.readthedocs.io/en/1.2.1/class.html#midiutil.MidiFile.MIDIFile.addTimeSignature
    denominator  = negative power of two: log10( X ) / log10( 2 ) 
    2 represents a quarter-note, 3 an eighth-note, etc.
    """
    metro            = pista.base['metro'].split( '/' )
    numerador        = int( metro[0] ) 
    denominador      = int( math.log10( int( metro[1] ) ) / math.log10( 2 ) )
    relojes_por_tick = 12 * denominador
    notas_por_negra  = 8
    opus.addTimeSignature( 
      track,
      momento,
      numerador,
      denominador,
      relojes_por_tick, 
      notas_por_negra
    )
  if 'clave' in pista.base:
    opus.addKeySignature(
      track,
      momento,
      pista.base[ 'clave' ][ 'alteraciones' ],
      1, # multiplica por el n de alteraciones
      pista.base[ 'clave' ][ 'modo' ]
    )
  if 'programa' in pista.base:
    opus.addProgramChange(
      track,
      pista.base[ 'canal' ],
      momento,  
      pista.base[ 'programa' ]
    )

  for index, evento in enumerate( pista.secuencia ):
    verboseprint( evento )
    previo = pista.secuencia[ index - 1 ]
    unidad = evento[ 'unidad' ]
    previa = previo[ 'unidad' ]
    canal = evento[ 'canal' ]
    bpm = evento[ 'bpm' ]
    if ( previo['bpm'] != bpm ):
      opus.addTempo(
        track,
        momento,
        bpm,
      )
    metro = evento[ 'metro' ]
    if ( previo[ 'metro' ] != metro ):
      metro            = evento[ 'metro' ].split( '/' )
      numerador        = int( metro[ 0 ] ) 
      denominador      = int( math.log10( int( metro[ 1 ] ) ) / math.log10( 2 ) )
      relojes_por_tick = 12 * denominador
      notas_por_negra  = 8
      opus.addTimeSignature( 
        track,
        momento,
        numerador,
        denominador,
        relojes_por_tick, 
        notas_por_negra
      )
    clave = evento[ 'clave' ]
    if ( previo[ 'clave' ] != clave ):
     opus.addKeySignature(
       track,
       momento,
       clave[ 'alteraciones' ],
       1, # multiplica por el n de alteraciones
       clave[ 'modo' ]
     )
    programa = evento[ 'programa' ]
    if programa:
      if ( previo[ 'programa' ] != programa ):
        opus.addProgramChange(
          track,
          canal, 
          momento, 
          programa
        )
        #opus.addText( pista.orden, momento , 'prgm : #' + str( programa ) )
    if ( evento[ 'orden' ] == 0 ):
      #verboseprint( st )
      st = ''
      if (
         'referente' in evento
      ) and(
         evento[ 'referente' ] is not None  
      ):
        ers = referir( evento[ 'referente' ] )  
        if ( 'referente' in previo ) and ( previo[ 'referente' ] != None ):
          prs = referir( previo[ 'referente' ] ) 
          if ers != prs:
            for i, er in enumerate( ers ) :
              pr = prs[ i % len( prs ) ] # TODO buscar mejor manera de limitar 
              if er != pr: 
                st += er[ 0 ] + ' #' + str( er[ 1 ] ) + '\n' 
      st += unidad 
      opus.addText(
        track,
        momento,
        st
      )
    voces = evento[ 'acorde' ] if evento[ 'acorde' ] else [ evento[ 'altura' ] ]
    dinamica = int( evento[ 'dinamica' ] * 126 )
    duracion = evento[ 'duracion' ] 

    for voz in voces:
      altura = voz 
      if voz == 'S':
        dinamica = 0
        altura = 0
      opus.addNote( 
        track, 
        canal, 
        altura, 
        momento, 
        duracion, 
        dinamica,
      )
    if evento[ 'controlador' ]:
      for controlador, parametro in evento[ 'controlador' ].items():
        opus.addControllerEvent( 
          track, 
          canal, 
          momento, 
          controlador, 
          parametro, 
        )
    momento += duracion

with open( salida + ".mid", "wb" ) as output_file:
  """
  Salida
  """
  opus.writeFile( output_file )




