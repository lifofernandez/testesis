#!/usr/bin/env python
from argumentos import args, verboseprint
import yaml
import math
import random
from midiutil import MIDIFile
from pista import Pista

definiciones = []
for archivo in args.archivos:
  data = open( archivo.name, 'r' )
  definiciones.append( yaml.load( data ) )

salida = args.output

### referir
def referir(
  refs,
  o = None,
  ):
  """
  Extrae referentes recursivamente
  """
  referente   = refs[ 'referente' ]   if 'referente'   in refs else None
  nombre      = refs[ 'nombre' ]      if 'nombre'      in refs else None
  recurrencia = refs[ 'recurrencia' ] if 'recurrencia' in refs else None
  nivel       = refs[ 'nivel' ]       if 'nivel'       in refs else None
  output      = o                     if o is not None         else [ None ] * nivel 
  output[ nivel - 1 ] = ( nombre, recurrencia )
  if referente:
    referir( referente, output )
  return output

### load
pistas = []
for d in definiciones:
  """
  Carga de pistas a partir de las definiciones
  """
  pista = Pista(
    d[ 'nombre' ],
    d[ 'base' ],
    d[ 'unidades' ],
    d[ 'macroforma' ],
  )
  pistas.append( pista )

### main
MIDIS = []
for pista in pistas:
  """
  Loop principal:
  Convierte secuencia de eventos a eventos midi
  TODO: agregar funcciones adicionales:
  https://midiutil.readthedocs.io/en/1.2.1/class.html#classref
  """
  momento = 0
  track = pista.orden

  MIDIS.append([
    'addTrackName',
    track,
    momento,
    pista.nombre
  ])

  if 'bpm' in pista.base:
    MIDIS.append([
      'addTempo',
      track,
      momento,
      pista.base['bpm']
    ])

  if 'metro' in pista.base:
    """
    Time Signature event
    https://midiutil.readthedocs.io/en/1.2.1/class.html#midiutil.MidiFile.MIDIFile.addTimeSignature
    denominator  = negative power of two: log10( X ) / log10( 2 ) 
    2 represents a quarter-note, 3 an eighth-note, etc.
    """
    metro            = pista.base['metro'].split( '/' )
    numerador        = int( metro[0] ) 
    denominador      = int( math.log10( int( metro[1] ) ) / math.log10( 2 ) )
    relojes_por_tick = 12 * denominador
    notas_por_negra  = 8
    MIDIS.append([
      'addTimeSignature',
      track,
      momento,
      numerador,
      denominador,
      relojes_por_tick, 
      notas_por_negra
    ])

  if 'clave' in pista.base:
    MIDIS.append([
      'addKeySignature',
      track,
      momento,
      pista.base[ 'clave' ][ 'alteraciones' ],
      1, # multiplica por el n de alteraciones
      pista.base[ 'clave' ][ 'modo' ]
    ])

  if 'programa' in pista.base:
    MIDIS.append([
      'addProgramChange',
      track,
      pista.base[ 'canal' ],
      momento,  
      pista.base[ 'programa' ]
    ])

  for index, evento in enumerate( pista.secuencia ):
    verboseprint( evento )
    previo = pista.secuencia[ index - 1 ]
    unidad = evento[ 'unidad' ]
    previa = previo[ 'unidad' ]
    canal = evento[ 'canal' ]
    bpm = evento[ 'bpm' ]

    if ( previo['bpm'] != bpm ):
      MIDIS.append([
        'addTempo',
        track,
        momento,
        bpm,
      ])
    metro = evento[ 'metro' ]

    if ( previo[ 'metro' ] != metro ):
      metro            = evento[ 'metro' ].split( '/' )
      numerador        = int( metro[ 0 ] ) 
      denominador      = int( math.log10( int( metro[ 1 ] ) ) / math.log10( 2 ) )
      relojes_por_tick = 12 * denominador
      notas_por_negra  = 8
      MIDIS.append([
        'addTimeSignature',
        track,
        momento,
        numerador,
        denominador,
        relojes_por_tick, 
        notas_por_negra
      ])
    clave = evento[ 'clave' ]

    if ( previo[ 'clave' ] != clave ):
      MIDIS.append([
        'addKeySignature',
        track,
        momento,
        clave[ 'alteraciones' ],
        1, # multiplica por el n de alteraciones
        clave[ 'modo' ]
      ])
    programa = evento[ 'programa' ]

    if programa:
      if ( previo[ 'programa' ] != programa ):
        MIDIS.append([
          'addProgramChange',
          track,
          canal, 
          momento, 
          programa
        ])
        #opus.addText( pista.orden, momento , 'prgm : #' + str( programa ) )

    if ( evento[ 'orden' ] == 0 ):
      # al igual que revertir, es un modificador de unidad ¿deberia "herederse"?
      desplazar = evento[ 'desplazar' ] 
      momento += desplazar 
      texto = ''
      evento_referentes = referir( evento[ 'referente' ] ) if evento[ 'referente' ] != None else [( 0, 0 )]
      previo_referentes = referir( previo[ 'referente' ] ) if previo[ 'referente' ] != None else [( 0, 0 )]
      for er, pr in zip( evento_referentes , previo_referentes ):
        if er != pr: 
          texto += str( er[ 0 ] ) + ' #' + str( er[ 1 ] ) + '\n' 
      texto += unidad 

      MIDIS.append([
       'addText',
        track,
        momento,
        texto 
      ])

    voces = evento[ 'acorde' ] if evento[ 'acorde' ] else [ evento[ 'altura' ] ]
    dinamica = int( evento[ 'dinamica' ] * 126 )
    duracion = evento[ 'duracion' ] 

    for voz in voces:
      altura = voz 
      if voz == 'S':
        dinamica = 0
        altura = 0
      MIDIS.append([
        'addNote',
        track, 
        canal, 
        altura, 
        momento, 
        duracion, 
        dinamica,
      ])

    if evento[ 'controlador' ]:
      for controlador, parametro in evento[ 'controlador' ].items():
        MIDIS.append([
         'addControllerEvent',
          track, 
          canal, 
          momento, 
          controlador, 
          parametro, 
        ])
    momento += duracion
### termina MAIN LOOP

### salida midi
opus = MIDIFile( Pista.cantidad ) 
for m in MIDIS:
    mu = getattr( opus, m[0] )( *m[1:] )
with open( salida + ".mid", "wb" ) as output_file:
  opus.writeFile( output_file )


### salida graf
if args.plotear:
  # TODO: rediseñar y eliminar redundancias con el loop anterior
  # pasar a otro fichero
  print( '#### CARGANDO libs ####' )
  import matplotlib.pyplot as ploter
  import numpy as np
  import matplotlib.dates as mdates
  from datetime import datetime, timedelta
  print( '#### PLOTEANDO ####' )
  for pista in pistas:
    momento = 0
    track = pista.orden
    grafico, eje_x = ploter.subplots( figsize = ( 8, 5 ) )
    levels = np.array( [-5, 5, -3, 3, -1, 1] )
    formato =  '%H:%M:%S'
    start = datetime.strptime( str( timedelta( seconds = 1 ) ), formato ) 
    dimension = sum( e['duracion'] * ( 60 / e['bpm'] ) for e in pista.secuencia ) 
    dimension = str( timedelta( seconds = dimension) )
    dimension = dimension.split('.')[0] 
    dimension = datetime.strptime( dimension, formato ) 
    stop  =  dimension
    eje_x.plot( 
      ( start, stop ),
      ( 0, 0 ),
      'k',
      alpha = .5
    )
    eje_x.set( title = pista.nombre )

    for index, evento in enumerate( pista.secuencia ):
      if ( evento[ 'orden' ] == 0 ):
        desplazar = evento[ 'desplazar' ] 
        momento += desplazar 
        texto = ''
        evento_referentes = referir( evento[ 'referente' ] ) if evento[ 'referente' ] != None else [( 0, 0 )]
        previo_referentes = referir( previo[ 'referente' ] ) if previo[ 'referente' ] != None else [( 0, 0 )]
        for er, pr in zip( evento_referentes , previo_referentes ):
          if er != pr: 
            texto += str( er[ 0 ] ) + ' #' + str( er[ 1 ] ) + '\n' 
        texto += evento['unidad'] 
        m =  momento * ( 60 / bpm) 
        t = str( timedelta( seconds = m ) )
        t = t.split('.')[0] # borra microsegundos
        idate = datetime.strptime( t , "%H:%M:%S" ) 
        level = levels[ index % 6 ]
        vert = 'top' if level < 0 else 'bottom'
        eje_x.scatter(
          idate,
          0,
          s = 100,
          facecolor = 'w',
          edgecolor = 'k',
          zorder = 9999
         )
         # Plot a line up to the text
        eje_x.plot(
          ( idate, idate ), 
          ( 0, level ), 
          c = 'r', 
          alpha = .7
        )
        # Give the text a faint background and align it properly
        eje_x.text(
           idate,
           level,
           texto,
           horizontalalignment = 'right',
           verticalalignment = vert,
           fontsize = 14,
           backgroundcolor = ( 1., 1., 1., .3 )
        )
      momento += evento[ 'duracion' ] 

    # Set the x ticks formatting
    # format x axis with 3 second intervals
    eje_x.get_xaxis().set_major_locator( mdates.SecondLocator( interval = 3 ) )
    eje_x.get_xaxis().set_major_formatter( mdates.DateFormatter( "%M %S" ) )
    grafico.autofmt_xdate()
    # Remove components for a cleaner look
    ploter.setp( 
      (
        eje_x.get_yticklabels() + 
        eje_x.get_yticklines() +
        list( eje_x.spines.values() )
      ),
      visible = False
    )
  ploter.show()


"""
TO DO:
    [ ] Encapzular como modulo de python
    [ ] Desplazar
    [ ] Error Hanglin, Rolando / YAML validation / Debug output
    [ ] Ploteo

TEMITAS:
    [x] Revisar transportar
    [ ] Revisar diferentes tempos en diferentes traks
"""
